//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v10.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace Vipps.net.Models.Login
{
    using System = global::System;

    

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class JSONWebKey
    {
        /// <summary>
        /// The 'alg' (algorithm) parameter identifies the algorithm intended for use for the key.  The values used should either be registered in the IANA 'JSON Web Signature and Encryption Algorithms' registry established by [JWA] or be a value that contains a collision resistant name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Alg { get; set; }

        [Newtonsoft.Json.JsonProperty("crv", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Crv { get; set; }

        [Newtonsoft.Json.JsonProperty("d", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string D { get; set; }

        [Newtonsoft.Json.JsonProperty("dp", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dp { get; set; }

        [Newtonsoft.Json.JsonProperty("dq", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dq { get; set; }

        [Newtonsoft.Json.JsonProperty("e", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string E { get; set; }

        [Newtonsoft.Json.JsonProperty("k", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string K { get; set; }

        /// <summary>
        /// The "kid" (key ID) parameter is used to match a specific key. This
        /// <br/>is used, for example, to choose among a set of keys within a JWK Set
        /// <br/>during key rollover. The format of the "kid" value is
        /// <br/>unspecified.  When "kid" values are used within a JWK Set, different
        /// <br/>keys within the JWK Set SHOULD use distinct "kid" values.  (One
        /// <br/>example in which different keys might use the same "kid" value is if
        /// <br/>they have different "kty" (key type) values but are considered to be
        /// <br/>equivalent alternatives by the application using them.)  The "kid"
        /// <br/>value is a case-sensitive string.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Kid { get; set; }

        /// <summary>
        /// The "kty" (key type) parameter identifies the cryptographic
        /// <br/>algorithm
        /// <br/>
        /// <br/>family used with the key, such as "RSA" or "EC". "kty" values should
        /// <br/>
        /// <br/>either be registered in the IANA "JSON Web Key Types" registry
        /// <br/>
        /// <br/>established by [JWA] or be a value that contains a Collision-
        /// <br/>
        /// <br/>Resistant Name.  The "kty" value is a case-sensitive string.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kty", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Kty { get; set; }

        [Newtonsoft.Json.JsonProperty("n", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string N { get; set; }

        [Newtonsoft.Json.JsonProperty("p", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string P { get; set; }

        [Newtonsoft.Json.JsonProperty("q", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Q { get; set; }

        [Newtonsoft.Json.JsonProperty("qi", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Qi { get; set; }

        /// <summary>
        /// Use ("public key use") identifies the intended use of
        /// <br/>the public key. The "use" parameter is employed to indicate whether
        /// <br/>a public key is used for encrypting data or verifying the signature
        /// <br/>on data. Values are commonly "sig" (signature) or "enc" (encryption).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Use { get; set; }

        [Newtonsoft.Json.JsonProperty("x", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string X { get; set; }

        /// <summary>
        /// The "x5c" (X.509 certificate chain) parameter contains a chain of
        /// <br/>one or more PKIX certificates [RFC5280].  The certificate chain is
        /// <br/>represented as a JSON array of certificate value strings.  Each
        /// <br/>string in the array is a base64-encoded (Section 4 of [RFC4648] --
        /// <br/>not base64url-encoded) DER [ITU.X690.1994] PKIX certificate value.
        /// <br/>The PKIX certificate containing the key value MUST be the first
        /// <br/>certificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("x5c", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> X5c { get; set; }

        [Newtonsoft.Json.JsonProperty("y", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Y { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class JSONWebKeySet
    {
        /// <summary>
        /// The value of the 'keys' parameter is an array of JWK values.  By default, the order of the JWK values within the array does not imply an order of preference among them, although applications of JWK Sets can choose to assign a meaning to the order for their purposes, if desired.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keys", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<JSONWebKey> Keys { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// It includes links to several endpoints (e.g. /oauth2/token) and exposes information on supported signature algorithms among others.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class WellKnown
    {
        /// <summary>
        /// URL of the OP's OAuth 2.0 Authorization Endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorization_endpoint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Authorization_endpoint { get; set; }

        /// <summary>
        /// Boolean value specifying whether the OP supports use of the claims parameter, with true indicating support.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("claims_parameter_supported", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Claims_parameter_supported { get; set; }

        /// <summary>
        /// JSON array containing a list of the Claim Names of the Claims that the OpenID Provider MAY be able to supply values for. Note that for privacy or other reasons, this might not be an exhaustive list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("claims_supported", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Claims_supported { get; set; }

        /// <summary>
        /// JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("grant_types_supported", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Grant_types_supported { get; set; }

        /// <summary>
        /// JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for the ID Token to encode the Claims in a JWT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id_token_signing_alg_values_supported", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Id_token_signing_alg_values_supported { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// URL using the https scheme with no query or fragment component that the OP asserts as its IssuerURL Identifier. If IssuerURL discovery is supported , this value MUST be identical to the issuer value returned by WebFinger. This also MUST be identical to the iss Claim value in ID Tokens issued from this IssuerURL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issuer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Issuer { get; set; }

        /// <summary>
        /// URL of the OP's JSON Web Key Set [JWK] document. This contains the signing key(s) the RP uses to validate signatures from the OP. The JWK Set MAY also contain the Server's encryption key(s), which are used by RPs to encrypt requests to the Server. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("jwks_uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Jwks_uri { get; set; }

        /// <summary>
        /// Boolean value specifying whether the OP supports use of the request parameter, with true indicating support.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_parameter_supported", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Request_parameter_supported { get; set; }

        /// <summary>
        /// Boolean value specifying whether the OP supports use of the request_uri parameter, with true indicating support.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_uri_parameter_supported", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Request_uri_parameter_supported { get; set; }

        /// <summary>
        /// Boolean value specifying whether the OP requires any request_uri values used to be pre-registered using the request_uris registration parameter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("require_request_uri_registration", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Require_request_uri_registration { get; set; }

        /// <summary>
        /// JSON array containing a list of the OAuth 2.0 response_mode values that this OP supports.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_modes_supported", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Response_modes_supported { get; set; }

        /// <summary>
        /// JSON array containing a list of the OAuth 2.0 response_type values that this OP supports.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_types_supported", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Response_types_supported { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports. The server MUST support the openid scope value. Servers MAY choose not to advertise some supported scope values even when this parameter is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scopes_supported", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Scopes_supported { get; set; }

        /// <summary>
        /// JSON array containing a list of the Subject Identifier types that this OP supports. Valid types include pairwise and public.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subject_types_supported", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Subject_types_supported { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// URL of the OP's OAuth 2.0 Token Endpoint
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token_endpoint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Token_endpoint { get; set; }

        /// <summary>
        /// JSON array containing a list of Client Authentication methods supported by this Token Endpoint. The options are client_secret_post, client_secret_basic, client_secret_jwt, and private_key_jwt, as described in Section 9 of OpenID Connect Core 1.0
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token_endpoint_auth_methods_supported", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Token_endpoint_auth_methods_supported { get; set; }
        
        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The token response
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class OauthTokenResponse
    {
        /// <summary>
        /// The access token issued by the authorization server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("access_token", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Access_token { get; set; }

        /// <summary>
        /// The lifetime in seconds of the access token.  For example, the value
        /// <br/>"3600" denotes that the access token will
        /// <br/>expire in one hour from the time the response was generated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expires_in", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long Expires_in { get; set; }

        /// <summary>
        /// To retrieve a refresh token request the id_token scope.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id_token", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long Id_token { get; set; }

        /// <summary>
        /// The refresh token, which can be used to obtain new
        /// <br/>access tokens. To retrieve it add the scope "offline" to your access token request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("refresh_token", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Refresh_token { get; set; }

        /// <summary>
        /// The scope of the access token
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scope { get; set; }

        /// <summary>
        /// The type of the token issued
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token_type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Token_type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Error responses are sent when an error (e.g. unauthorized, bad request, etc) occurred.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class ErrorResponse
    {
        /// <summary>
        /// Name is the error name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Error { get; set; }

        /// <summary>
        /// Code represents the error status code (404, 403, 401, ...).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_code", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long Error_code { get; set; }

        /// <summary>
        /// Debug contains debug information. This is usually not available and has to be enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_debug", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_debug { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v10.0.0.0))")]
    public partial class Body
    {
        /// <summary>
        /// Value MUST be authorization_code.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("grant_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Grant_type { get; set; }

        /// <summary>
        /// The authorization code received from the authorization server as a query param on the redirect_uri.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Code { get; set; }

        /// <summary>
        /// The redirect URL which the user agent is redirected to after finishing a login.
        /// <br/>If the URL is using a custom URL scheme, such as myapp://, a path is required: myapp://path-to-something.
        /// <br/>The URL must be exactly the same as the one specified on portal.vipps.no.
        /// <br/>Be extra careful with trailing slashes and URL-encoded entities.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("redirect_uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Redirect_uri { get; set; }

        /// <summary>
        /// The `client_id` is available on portal.vipps.no, under the 'Utvikler' tab.
        /// <br/>This parameter is required if the token endpoint authentication method is set to `client_secret_post`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Client_id { get; set; }

        /// <summary>
        /// The `client_secret` is available on portal.vipps.no, under the 'Utvikler' tab.
        /// <br/>This parameter is required if the token endpoint authentication method is set to `client_secret_post`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_secret", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Client_secret { get; set; }

        /// <summary>
        /// Required if PKCE, https://tools.ietf.org/html/rfc7636, is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("code_verifier", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code_verifier { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }
    }
    
    public partial class StartLoginURIRequest 
    {
        public string Scope { get; set; }
        public string RedirectURI { get; set; }
        public AuthenticationMethod AuthenticationMethod { get; set; }
    }
    
    public enum AuthenticationMethod
    {
        Basic,
        Post
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
#pragma warning restore 3016
#pragma warning restore 8603
